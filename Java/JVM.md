## 二、Java内存区域与内存管理

### Java内存划分

### Hotspot虚拟机与内存

#### 对象的创建

`new 指令`、`常量池定位符号引用`、`类加载检查`、`对象分配内存`、`<init>方法`



对象分配内存

- 指针碰撞
  - 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离
  - 指针碰撞要求内存空间是连续的，所以只适合那些存在内存整理的（Compacting）
- 空闲列表
  - 如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

#### 对象的内存布局

#### 对象的访问定位

## 三、垃圾回收器与内存分配

> 三件事
>
> 1. 哪些内存需要回收
> 2. 什么时候回收
> 3. 如何回收

### 3.1 如何确定不再使用的对象

#### 3.1.1 引用计数法

在对象上添加一个引用计数器，每当有一个地方在引用它，计数器就加一，取消引用就减一，计数器为零的就是不再使用的，但是引用计数法存在缺点：很难解决循环引用的问题

#### 3.1.2 可达性分析

通过GC Roots根对象作为起始节点，从根节点开始，根据引用关系进行搜索，如果可以与GC Roots不相关联，则认为是不会再被使用的

##### 哪些可以作为GC Roots

以下是固定的

- 在虚拟机栈引用的对象（栈帧中的本地变量表）比如：参数、局部变量、临时变量等
- 方法区中静态引用的对象，比如引用类型静态变量
- 方法区中常量引用的对象，比如字符串常量池
- 本地方法栈中JNI引用的对象
- Java虚拟机内部的引用，如：常驻的异常对象、系统类加载器
- 所有被同步锁持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存

还有一些是临时加入的



#### 3.1.3 引用的类型

- Strongly Reference
  - 普遍存在的引用赋值==Object a = new Object
  - 只要存在，垃圾回收器就不会回收被引用的对象
- Soft Reference
  - 描述一些还存在，但是非必须的对象
  - 只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常
- Weak Reference
  - 也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象
- Phantom Reference
  - 它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。



#### 3.1.4 回收分析

- 01 可达性分析

  - 与GC Roots相关联对象------跳过

  - 与GC Roots无关联对象------进行第一次标记

    - 进行筛选（此对象是否有必要执行finalize()方法）

      > finalize方法只会被执行一次

      - 没有必要执行，则会被直接回收掉-----（未覆盖finalize方法 或 finalize方法已经执行过）

      - 有必要执行

        - 添加进F-Queue队列，并等待Finalizer线程执行finalize方法

          > Finalizer线程由虚拟机自动建立的、低调度优先级；“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃

          - 对F-Queue中的对象进行第二次小规模的标记

            > 只要重新与引用链上的任何一个对象建立关联即可成功拯救自己，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，它将被移出“即将回收”的集合

 



```java
package com.nanchaos.tech.demo;

/**
 * copy from 周志明大佬的《深入理解Java虚拟机 第三版》
 * 此代码演示了两点：
 * 1.对象可以在被GC时自我拯救。
 * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
 * @author zzm
 */
public class FinalizeEscapeGC {

    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.out.println("yes, i am still alive :)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();

        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.out.println("is going to run GC");
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead :(");
        }

        // 下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead :(");
        }
    }
}
```



#### 3.1.5 回收方法区

《Java虚拟机规范》不要求虚拟机在方法区中实现垃圾收集，回收的性价比也很低。方法区的垃圾收集主要回收两部分内容：`废弃的常量`和`不再使用的类型`。

##### 常量回收

条件：没有任何字符串对象引用常量池中的当前常量，且虚拟机中也没有其他地方引用这个字面量

##### 类型回收

条件如下

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
- 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

但也并非满足了上述三个条件就一定会被回收



### 3.2 垃圾回收算法

> Richard Jones 《垃圾回收算法手册》

#### 3.2.1 分代收集理论

##### 几个分代假说

- 弱分代假说
  - 绝大多数对象都是朝生夕灭的。
- 强分代假说
  - 熬过越多次垃圾收集过程的对象就越难以消亡。
- 跨代引用假说
  - 跨代引用相对于同代引用来说仅占极少数。


前两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。也就关联到了常常听到的`新生代`、`老年代`（忽略永生代，永生代后来被Metaspace取代了）等词汇，以及`Minor GC`、`Major GC`、`Full GC`等回收类型，并出现了与之匹配的不同垃圾回收算法，包括`标记-复制`、`标记-清除`、`标记-整理`。

跨代引用假说：如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了

> Partial GC，顾名思义：部分GC，即不是对整个Java堆进行回收，包括以下
>
> - Minor GC / Young GC:：新生代收集
> - Major GC / Old GC：老年代收集，目前只有CMS收集器会有单独收集老年代的行为，而Major GC有语义歧义，有的时候会指整堆收集
> - Mixed GC：标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为
>
> Full GC：收集整个Java堆和方法区的垃圾收集。注意：目前方法区不太可能会被垃圾回收，所以大概率还是堆



#### 3.2.2 垃圾收集算法

##### 标记-清除算法（Mark-Sweep）

分为两个阶段

- 首先标记出所有需要回收的对象
- 在标记完成后，统一回收掉所有被标记的对象

也可以反过来

- 首先标记出所有不需要回收的对象，即存活的
- 在标记完成后，统一回收所有未被标记的对象



主要缺点：

- 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
- 内存空间碎片化，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

所以：适合存活量多的，这样标记的也比较少，碎片比较少



##### 标记-复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

缺点：将可用内存缩小为了原来的一半，空间浪费未免有点多，在对象存活率较高时就要进行较多的复制操作

所以：适合存活量比较少的，这样复制的就少，即新生代



研究发现：98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。所以也有了半区复制分代策略（**Appel式回收**）

**Appel式回收**

把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间，HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1。

如果不止呢，就是说有超过10%的存货对象，8:1的分配策略就不足了

- 所以，有了`逃生门`安全策略：当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保，进入老年代。



![image-20250126170353190](./assets/image-20250126170353190.png)

##### 标记整理算法（Mark-Compact）

三个阶段

- 首先标记出所有不需要回收的对象，即存活的
- 让所有存活的对象都向内存空间一端移动
- 直接清理掉边界以外的内存

而移动时，因为老年代有大量对象存活，所以很繁重，必须全程暂停用户应用程序才能进行，也就有了`STW`（Stop The World）

问题：必须移动对象吗？不移动和移动到底谁划算？

答：取决于吞吐量。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。吞吐量的实质是赋值器与收集器的效率总和，即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的

- 关注延迟 --- HotSpot虚拟机 CMS收集器
- 关注吞吐量 --- HotSpot虚拟机 Parallel Scavenge收集器



也有两种都采用的方式：平时使用标记-整理，留下空间碎片，等到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次。



### 3.3 Hotsopt虚拟机实现

暂时略



### 3.4 经典垃圾收集器

#### 3.4.1 Serial收集器

在JDK 1.3.1之前是HotSpot虚拟机新生代收集器的唯一选择。迄今为止，它依然是HotSpot虚拟机运行在**客户端**模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效

![image-20250126172347781](./assets/image-20250126172347781.png)



#### 3.4.2 ParNew收集器

JDK 1.4.2之后发布

ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。式下的HotSpot虚拟机是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作

> CMS：老年代收集器，JDK5发布，关注停顿时间

![image-20250126172558099](./assets/image-20250126172558099.png)



#### 3.4.3 Parallel Scavenge收集器

JDK 1.4.2之后发布

Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值

#### 3.4.4 Serial Old收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。

如果在服务端模式下，它也可能有两种用途

- JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用
  - 但其实Parallel Scavenge有老年代的PS MarkSweep实现，但是该收集器与Serial Old的实现是几乎完全一样的
- CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用

![image-20250126174428321](./assets/image-20250126174428321.png)

#### 3.4.5 Parallel Old收集器

JDK6发布

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。这个收集器是直到JDK 6时才开始提供的

![image-20250126174542470](./assets/image-20250126174542470.png)



#### 3.4.6 CMS收集器（Concurrent Mark Sweep）

是以获取最短回收停顿时间为目标的收集器，比一遍的标记清除要复杂一点

- 01 初始标记（CMS initial mark） --- STW
  - 只是标记一下GC Roots能直接关联到的对象，速度很快
- 02 并发标记（CMS concurrent mark）
  - 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
- 03 重新标记（CMS remark） --- STW
  - 则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录
- 04 并发清除（CMS concurrent sweep）
  - 清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

并发标记和并发清除阶段在整个过程中耗时最长，但可以与用户线程一起工作

![image-20250126175106620](./assets/image-20250126175106620.png)
